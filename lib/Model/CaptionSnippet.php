<?php
/**
 * CaptionSnippet
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * YouTube Data
 *
 * Supports core YouTube features, such as uploading videos, creating and managing playlists, searching for content, and much more.
 *
 * OpenAPI spec version: v3
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * CaptionSnippet Class Doc Comment
 *
 * @category Class
 * @description Basic details about a caption track, such as its language and name.
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class CaptionSnippet implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'CaptionSnippet';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'audio_track_type' => 'string',
        'failure_reason' => 'string',
        'is_auto_synced' => 'bool',
        'is_cc' => 'bool',
        'is_draft' => 'bool',
        'is_easy_reader' => 'bool',
        'is_large' => 'bool',
        'language' => 'string',
        'last_updated' => '\DateTime',
        'name' => 'string',
        'status' => 'string',
        'track_kind' => 'string',
        'video_id' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'audio_track_type' => null,
        'failure_reason' => null,
        'is_auto_synced' => null,
        'is_cc' => null,
        'is_draft' => null,
        'is_easy_reader' => null,
        'is_large' => null,
        'language' => null,
        'last_updated' => 'date-time',
        'name' => null,
        'status' => null,
        'track_kind' => null,
        'video_id' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'audio_track_type' => 'audioTrackType',
        'failure_reason' => 'failureReason',
        'is_auto_synced' => 'isAutoSynced',
        'is_cc' => 'isCC',
        'is_draft' => 'isDraft',
        'is_easy_reader' => 'isEasyReader',
        'is_large' => 'isLarge',
        'language' => 'language',
        'last_updated' => 'lastUpdated',
        'name' => 'name',
        'status' => 'status',
        'track_kind' => 'trackKind',
        'video_id' => 'videoId'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'audio_track_type' => 'setAudioTrackType',
        'failure_reason' => 'setFailureReason',
        'is_auto_synced' => 'setIsAutoSynced',
        'is_cc' => 'setIsCc',
        'is_draft' => 'setIsDraft',
        'is_easy_reader' => 'setIsEasyReader',
        'is_large' => 'setIsLarge',
        'language' => 'setLanguage',
        'last_updated' => 'setLastUpdated',
        'name' => 'setName',
        'status' => 'setStatus',
        'track_kind' => 'setTrackKind',
        'video_id' => 'setVideoId'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'audio_track_type' => 'getAudioTrackType',
        'failure_reason' => 'getFailureReason',
        'is_auto_synced' => 'getIsAutoSynced',
        'is_cc' => 'getIsCc',
        'is_draft' => 'getIsDraft',
        'is_easy_reader' => 'getIsEasyReader',
        'is_large' => 'getIsLarge',
        'language' => 'getLanguage',
        'last_updated' => 'getLastUpdated',
        'name' => 'getName',
        'status' => 'getStatus',
        'track_kind' => 'getTrackKind',
        'video_id' => 'getVideoId'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const AUDIO_TRACK_TYPE_COMMENTARY = 'commentary';
    const AUDIO_TRACK_TYPE_DESCRIPTIVE = 'descriptive';
    const AUDIO_TRACK_TYPE_PRIMARY = 'primary';
    const AUDIO_TRACK_TYPE_UNKNOWN = 'unknown';
    const FAILURE_REASON_PROCESSING_FAILED = 'processingFailed';
    const FAILURE_REASON_UNKNOWN_FORMAT = 'unknownFormat';
    const FAILURE_REASON_UNSUPPORTED_FORMAT = 'unsupportedFormat';
    const STATUS_FAILED = 'failed';
    const STATUS_SERVING = 'serving';
    const STATUS_SYNCING = 'syncing';
    const TRACK_KIND_ASR = 'ASR';
    const TRACK_KIND_FORCED = 'forced';
    const TRACK_KIND_STANDARD = 'standard';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAudioTrackTypeAllowableValues()
    {
        return [
            self::AUDIO_TRACK_TYPE_COMMENTARY,
            self::AUDIO_TRACK_TYPE_DESCRIPTIVE,
            self::AUDIO_TRACK_TYPE_PRIMARY,
            self::AUDIO_TRACK_TYPE_UNKNOWN,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getFailureReasonAllowableValues()
    {
        return [
            self::FAILURE_REASON_PROCESSING_FAILED,
            self::FAILURE_REASON_UNKNOWN_FORMAT,
            self::FAILURE_REASON_UNSUPPORTED_FORMAT,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_FAILED,
            self::STATUS_SERVING,
            self::STATUS_SYNCING,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTrackKindAllowableValues()
    {
        return [
            self::TRACK_KIND_ASR,
            self::TRACK_KIND_FORCED,
            self::TRACK_KIND_STANDARD,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['audio_track_type'] = isset($data['audio_track_type']) ? $data['audio_track_type'] : null;
        $this->container['failure_reason'] = isset($data['failure_reason']) ? $data['failure_reason'] : null;
        $this->container['is_auto_synced'] = isset($data['is_auto_synced']) ? $data['is_auto_synced'] : null;
        $this->container['is_cc'] = isset($data['is_cc']) ? $data['is_cc'] : null;
        $this->container['is_draft'] = isset($data['is_draft']) ? $data['is_draft'] : null;
        $this->container['is_easy_reader'] = isset($data['is_easy_reader']) ? $data['is_easy_reader'] : null;
        $this->container['is_large'] = isset($data['is_large']) ? $data['is_large'] : null;
        $this->container['language'] = isset($data['language']) ? $data['language'] : null;
        $this->container['last_updated'] = isset($data['last_updated']) ? $data['last_updated'] : null;
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['status'] = isset($data['status']) ? $data['status'] : null;
        $this->container['track_kind'] = isset($data['track_kind']) ? $data['track_kind'] : null;
        $this->container['video_id'] = isset($data['video_id']) ? $data['video_id'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getAudioTrackTypeAllowableValues();
        if (!in_array($this->container['audio_track_type'], $allowedValues)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'audio_track_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getFailureReasonAllowableValues();
        if (!in_array($this->container['failure_reason'], $allowedValues)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'failure_reason', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStatusAllowableValues();
        if (!in_array($this->container['status'], $allowedValues)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'status', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getTrackKindAllowableValues();
        if (!in_array($this->container['track_kind'], $allowedValues)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'track_kind', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {

        $allowedValues = $this->getAudioTrackTypeAllowableValues();
        if (!in_array($this->container['audio_track_type'], $allowedValues)) {
            return false;
        }
        $allowedValues = $this->getFailureReasonAllowableValues();
        if (!in_array($this->container['failure_reason'], $allowedValues)) {
            return false;
        }
        $allowedValues = $this->getStatusAllowableValues();
        if (!in_array($this->container['status'], $allowedValues)) {
            return false;
        }
        $allowedValues = $this->getTrackKindAllowableValues();
        if (!in_array($this->container['track_kind'], $allowedValues)) {
            return false;
        }
        return true;
    }


    /**
     * Gets audio_track_type
     *
     * @return string
     */
    public function getAudioTrackType()
    {
        return $this->container['audio_track_type'];
    }

    /**
     * Sets audio_track_type
     *
     * @param string $audio_track_type The type of audio track associated with the caption track.
     *
     * @return $this
     */
    public function setAudioTrackType($audio_track_type)
    {
        $allowedValues = $this->getAudioTrackTypeAllowableValues();
        if (!is_null($audio_track_type) && !in_array($audio_track_type, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'audio_track_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['audio_track_type'] = $audio_track_type;

        return $this;
    }

    /**
     * Gets failure_reason
     *
     * @return string
     */
    public function getFailureReason()
    {
        return $this->container['failure_reason'];
    }

    /**
     * Sets failure_reason
     *
     * @param string $failure_reason The reason that YouTube failed to process the caption track. This property is only present if the state property's value is failed.
     *
     * @return $this
     */
    public function setFailureReason($failure_reason)
    {
        $allowedValues = $this->getFailureReasonAllowableValues();
        if (!is_null($failure_reason) && !in_array($failure_reason, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'failure_reason', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['failure_reason'] = $failure_reason;

        return $this;
    }

    /**
     * Gets is_auto_synced
     *
     * @return bool
     */
    public function getIsAutoSynced()
    {
        return $this->container['is_auto_synced'];
    }

    /**
     * Sets is_auto_synced
     *
     * @param bool $is_auto_synced Indicates whether YouTube synchronized the caption track to the audio track in the video. The value will be true if a sync was explicitly requested when the caption track was uploaded. For example, when calling the captions.insert or captions.update methods, you can set the sync parameter to true to instruct YouTube to sync the uploaded track to the video. If the value is false, YouTube uses the time codes in the uploaded caption track to determine when to display captions.
     *
     * @return $this
     */
    public function setIsAutoSynced($is_auto_synced)
    {
        $this->container['is_auto_synced'] = $is_auto_synced;

        return $this;
    }

    /**
     * Gets is_cc
     *
     * @return bool
     */
    public function getIsCc()
    {
        return $this->container['is_cc'];
    }

    /**
     * Sets is_cc
     *
     * @param bool $is_cc Indicates whether the track contains closed captions for the deaf and hard of hearing. The default value is false.
     *
     * @return $this
     */
    public function setIsCc($is_cc)
    {
        $this->container['is_cc'] = $is_cc;

        return $this;
    }

    /**
     * Gets is_draft
     *
     * @return bool
     */
    public function getIsDraft()
    {
        return $this->container['is_draft'];
    }

    /**
     * Sets is_draft
     *
     * @param bool $is_draft Indicates whether the caption track is a draft. If the value is true, then the track is not publicly visible. The default value is false.
     *
     * @return $this
     */
    public function setIsDraft($is_draft)
    {
        $this->container['is_draft'] = $is_draft;

        return $this;
    }

    /**
     * Gets is_easy_reader
     *
     * @return bool
     */
    public function getIsEasyReader()
    {
        return $this->container['is_easy_reader'];
    }

    /**
     * Sets is_easy_reader
     *
     * @param bool $is_easy_reader Indicates whether caption track is formatted for \"easy reader,\" meaning it is at a third-grade level for language learners. The default value is false.
     *
     * @return $this
     */
    public function setIsEasyReader($is_easy_reader)
    {
        $this->container['is_easy_reader'] = $is_easy_reader;

        return $this;
    }

    /**
     * Gets is_large
     *
     * @return bool
     */
    public function getIsLarge()
    {
        return $this->container['is_large'];
    }

    /**
     * Sets is_large
     *
     * @param bool $is_large Indicates whether the caption track uses large text for the vision-impaired. The default value is false.
     *
     * @return $this
     */
    public function setIsLarge($is_large)
    {
        $this->container['is_large'] = $is_large;

        return $this;
    }

    /**
     * Gets language
     *
     * @return string
     */
    public function getLanguage()
    {
        return $this->container['language'];
    }

    /**
     * Sets language
     *
     * @param string $language The language of the caption track. The property value is a BCP-47 language tag.
     *
     * @return $this
     */
    public function setLanguage($language)
    {
        $this->container['language'] = $language;

        return $this;
    }

    /**
     * Gets last_updated
     *
     * @return \DateTime
     */
    public function getLastUpdated()
    {
        return $this->container['last_updated'];
    }

    /**
     * Sets last_updated
     *
     * @param \DateTime $last_updated The date and time when the caption track was last updated. The value is specified in ISO 8601 (YYYY-MM-DDThh:mm:ss.sZ) format.
     *
     * @return $this
     */
    public function setLastUpdated($last_updated)
    {
        $this->container['last_updated'] = $last_updated;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name The name of the caption track. The name is intended to be visible to the user as an option during playback.
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string $status The caption track's status.
     *
     * @return $this
     */
    public function setStatus($status)
    {
        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($status) && !in_array($status, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'status', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets track_kind
     *
     * @return string
     */
    public function getTrackKind()
    {
        return $this->container['track_kind'];
    }

    /**
     * Sets track_kind
     *
     * @param string $track_kind The caption track's type.
     *
     * @return $this
     */
    public function setTrackKind($track_kind)
    {
        $allowedValues = $this->getTrackKindAllowableValues();
        if (!is_null($track_kind) && !in_array($track_kind, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'track_kind', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['track_kind'] = $track_kind;

        return $this;
    }

    /**
     * Gets video_id
     *
     * @return string
     */
    public function getVideoId()
    {
        return $this->container['video_id'];
    }

    /**
     * Sets video_id
     *
     * @param string $video_id The ID that YouTube uses to uniquely identify the video associated with the caption track.
     *
     * @return $this
     */
    public function setVideoId($video_id)
    {
        $this->container['video_id'] = $video_id;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


