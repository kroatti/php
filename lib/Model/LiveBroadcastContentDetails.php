<?php
/**
 * LiveBroadcastContentDetails
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * YouTube Data
 *
 * Supports core YouTube features, such as uploading videos, creating and managing playlists, searching for content, and much more.
 *
 * OpenAPI spec version: v3
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * LiveBroadcastContentDetails Class Doc Comment
 *
 * @category Class
 * @description Detailed settings of a broadcast.
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class LiveBroadcastContentDetails implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'LiveBroadcastContentDetails';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'bound_stream_id' => 'string',
        'bound_stream_last_update_time_ms' => '\DateTime',
        'closed_captions_type' => 'string',
        'enable_auto_start' => 'bool',
        'enable_closed_captions' => 'bool',
        'enable_content_encryption' => 'bool',
        'enable_dvr' => 'bool',
        'enable_embed' => 'bool',
        'enable_low_latency' => 'bool',
        'latency_preference' => 'string',
        'mesh' => 'string',
        'monitor_stream' => '\Swagger\Client\Model\MonitorStreamInfo',
        'projection' => 'string',
        'record_from_start' => 'bool',
        'start_with_slate' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'bound_stream_id' => null,
        'bound_stream_last_update_time_ms' => 'date-time',
        'closed_captions_type' => null,
        'enable_auto_start' => null,
        'enable_closed_captions' => null,
        'enable_content_encryption' => null,
        'enable_dvr' => null,
        'enable_embed' => null,
        'enable_low_latency' => null,
        'latency_preference' => null,
        'mesh' => 'byte',
        'monitor_stream' => null,
        'projection' => null,
        'record_from_start' => null,
        'start_with_slate' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'bound_stream_id' => 'boundStreamId',
        'bound_stream_last_update_time_ms' => 'boundStreamLastUpdateTimeMs',
        'closed_captions_type' => 'closedCaptionsType',
        'enable_auto_start' => 'enableAutoStart',
        'enable_closed_captions' => 'enableClosedCaptions',
        'enable_content_encryption' => 'enableContentEncryption',
        'enable_dvr' => 'enableDvr',
        'enable_embed' => 'enableEmbed',
        'enable_low_latency' => 'enableLowLatency',
        'latency_preference' => 'latencyPreference',
        'mesh' => 'mesh',
        'monitor_stream' => 'monitorStream',
        'projection' => 'projection',
        'record_from_start' => 'recordFromStart',
        'start_with_slate' => 'startWithSlate'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'bound_stream_id' => 'setBoundStreamId',
        'bound_stream_last_update_time_ms' => 'setBoundStreamLastUpdateTimeMs',
        'closed_captions_type' => 'setClosedCaptionsType',
        'enable_auto_start' => 'setEnableAutoStart',
        'enable_closed_captions' => 'setEnableClosedCaptions',
        'enable_content_encryption' => 'setEnableContentEncryption',
        'enable_dvr' => 'setEnableDvr',
        'enable_embed' => 'setEnableEmbed',
        'enable_low_latency' => 'setEnableLowLatency',
        'latency_preference' => 'setLatencyPreference',
        'mesh' => 'setMesh',
        'monitor_stream' => 'setMonitorStream',
        'projection' => 'setProjection',
        'record_from_start' => 'setRecordFromStart',
        'start_with_slate' => 'setStartWithSlate'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'bound_stream_id' => 'getBoundStreamId',
        'bound_stream_last_update_time_ms' => 'getBoundStreamLastUpdateTimeMs',
        'closed_captions_type' => 'getClosedCaptionsType',
        'enable_auto_start' => 'getEnableAutoStart',
        'enable_closed_captions' => 'getEnableClosedCaptions',
        'enable_content_encryption' => 'getEnableContentEncryption',
        'enable_dvr' => 'getEnableDvr',
        'enable_embed' => 'getEnableEmbed',
        'enable_low_latency' => 'getEnableLowLatency',
        'latency_preference' => 'getLatencyPreference',
        'mesh' => 'getMesh',
        'monitor_stream' => 'getMonitorStream',
        'projection' => 'getProjection',
        'record_from_start' => 'getRecordFromStart',
        'start_with_slate' => 'getStartWithSlate'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const CLOSED_CAPTIONS_TYPE_CLOSED_CAPTIONS_DISABLED = 'closedCaptionsDisabled';
    const CLOSED_CAPTIONS_TYPE_CLOSED_CAPTIONS_EMBEDDED = 'closedCaptionsEmbedded';
    const CLOSED_CAPTIONS_TYPE_CLOSED_CAPTIONS_HTTP_POST = 'closedCaptionsHttpPost';
    const LATENCY_PREFERENCE_LOW = 'low';
    const LATENCY_PREFERENCE_NORMAL = 'normal';
    const LATENCY_PREFERENCE_ULTRA_LOW = 'ultraLow';
    const PROJECTION__360 = '360';
    const PROJECTION_MESH = 'mesh';
    const PROJECTION_RECTANGULAR = 'rectangular';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getClosedCaptionsTypeAllowableValues()
    {
        return [
            self::CLOSED_CAPTIONS_TYPE_CLOSED_CAPTIONS_DISABLED,
            self::CLOSED_CAPTIONS_TYPE_CLOSED_CAPTIONS_EMBEDDED,
            self::CLOSED_CAPTIONS_TYPE_CLOSED_CAPTIONS_HTTP_POST,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLatencyPreferenceAllowableValues()
    {
        return [
            self::LATENCY_PREFERENCE_LOW,
            self::LATENCY_PREFERENCE_NORMAL,
            self::LATENCY_PREFERENCE_ULTRA_LOW,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getProjectionAllowableValues()
    {
        return [
            self::PROJECTION__360,
            self::PROJECTION_MESH,
            self::PROJECTION_RECTANGULAR,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['bound_stream_id'] = isset($data['bound_stream_id']) ? $data['bound_stream_id'] : null;
        $this->container['bound_stream_last_update_time_ms'] = isset($data['bound_stream_last_update_time_ms']) ? $data['bound_stream_last_update_time_ms'] : null;
        $this->container['closed_captions_type'] = isset($data['closed_captions_type']) ? $data['closed_captions_type'] : null;
        $this->container['enable_auto_start'] = isset($data['enable_auto_start']) ? $data['enable_auto_start'] : null;
        $this->container['enable_closed_captions'] = isset($data['enable_closed_captions']) ? $data['enable_closed_captions'] : null;
        $this->container['enable_content_encryption'] = isset($data['enable_content_encryption']) ? $data['enable_content_encryption'] : null;
        $this->container['enable_dvr'] = isset($data['enable_dvr']) ? $data['enable_dvr'] : null;
        $this->container['enable_embed'] = isset($data['enable_embed']) ? $data['enable_embed'] : null;
        $this->container['enable_low_latency'] = isset($data['enable_low_latency']) ? $data['enable_low_latency'] : null;
        $this->container['latency_preference'] = isset($data['latency_preference']) ? $data['latency_preference'] : null;
        $this->container['mesh'] = isset($data['mesh']) ? $data['mesh'] : null;
        $this->container['monitor_stream'] = isset($data['monitor_stream']) ? $data['monitor_stream'] : null;
        $this->container['projection'] = isset($data['projection']) ? $data['projection'] : null;
        $this->container['record_from_start'] = isset($data['record_from_start']) ? $data['record_from_start'] : null;
        $this->container['start_with_slate'] = isset($data['start_with_slate']) ? $data['start_with_slate'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getClosedCaptionsTypeAllowableValues();
        if (!in_array($this->container['closed_captions_type'], $allowedValues)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'closed_captions_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getLatencyPreferenceAllowableValues();
        if (!in_array($this->container['latency_preference'], $allowedValues)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'latency_preference', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['mesh']) && !preg_match("/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/", $this->container['mesh'])) {
            $invalidProperties[] = "invalid value for 'mesh', must be conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.";
        }

        $allowedValues = $this->getProjectionAllowableValues();
        if (!in_array($this->container['projection'], $allowedValues)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'projection', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {

        $allowedValues = $this->getClosedCaptionsTypeAllowableValues();
        if (!in_array($this->container['closed_captions_type'], $allowedValues)) {
            return false;
        }
        $allowedValues = $this->getLatencyPreferenceAllowableValues();
        if (!in_array($this->container['latency_preference'], $allowedValues)) {
            return false;
        }
        if (!preg_match("/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/", $this->container['mesh'])) {
            return false;
        }
        $allowedValues = $this->getProjectionAllowableValues();
        if (!in_array($this->container['projection'], $allowedValues)) {
            return false;
        }
        return true;
    }


    /**
     * Gets bound_stream_id
     *
     * @return string
     */
    public function getBoundStreamId()
    {
        return $this->container['bound_stream_id'];
    }

    /**
     * Sets bound_stream_id
     *
     * @param string $bound_stream_id This value uniquely identifies the live stream bound to the broadcast.
     *
     * @return $this
     */
    public function setBoundStreamId($bound_stream_id)
    {
        $this->container['bound_stream_id'] = $bound_stream_id;

        return $this;
    }

    /**
     * Gets bound_stream_last_update_time_ms
     *
     * @return \DateTime
     */
    public function getBoundStreamLastUpdateTimeMs()
    {
        return $this->container['bound_stream_last_update_time_ms'];
    }

    /**
     * Sets bound_stream_last_update_time_ms
     *
     * @param \DateTime $bound_stream_last_update_time_ms The date and time that the live stream referenced by boundStreamId was last updated.
     *
     * @return $this
     */
    public function setBoundStreamLastUpdateTimeMs($bound_stream_last_update_time_ms)
    {
        $this->container['bound_stream_last_update_time_ms'] = $bound_stream_last_update_time_ms;

        return $this;
    }

    /**
     * Gets closed_captions_type
     *
     * @return string
     */
    public function getClosedCaptionsType()
    {
        return $this->container['closed_captions_type'];
    }

    /**
     * Sets closed_captions_type
     *
     * @param string $closed_captions_type closed_captions_type
     *
     * @return $this
     */
    public function setClosedCaptionsType($closed_captions_type)
    {
        $allowedValues = $this->getClosedCaptionsTypeAllowableValues();
        if (!is_null($closed_captions_type) && !in_array($closed_captions_type, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'closed_captions_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['closed_captions_type'] = $closed_captions_type;

        return $this;
    }

    /**
     * Gets enable_auto_start
     *
     * @return bool
     */
    public function getEnableAutoStart()
    {
        return $this->container['enable_auto_start'];
    }

    /**
     * Sets enable_auto_start
     *
     * @param bool $enable_auto_start This setting indicates whether auto start is enabled for this broadcast.
     *
     * @return $this
     */
    public function setEnableAutoStart($enable_auto_start)
    {
        $this->container['enable_auto_start'] = $enable_auto_start;

        return $this;
    }

    /**
     * Gets enable_closed_captions
     *
     * @return bool
     */
    public function getEnableClosedCaptions()
    {
        return $this->container['enable_closed_captions'];
    }

    /**
     * Sets enable_closed_captions
     *
     * @param bool $enable_closed_captions This setting indicates whether HTTP POST closed captioning is enabled for this broadcast. The ingestion URL of the closed captions is returned through the liveStreams API. This is mutually exclusive with using the closed_captions_type property, and is equivalent to setting closed_captions_type to CLOSED_CAPTIONS_HTTP_POST.
     *
     * @return $this
     */
    public function setEnableClosedCaptions($enable_closed_captions)
    {
        $this->container['enable_closed_captions'] = $enable_closed_captions;

        return $this;
    }

    /**
     * Gets enable_content_encryption
     *
     * @return bool
     */
    public function getEnableContentEncryption()
    {
        return $this->container['enable_content_encryption'];
    }

    /**
     * Sets enable_content_encryption
     *
     * @param bool $enable_content_encryption This setting indicates whether YouTube should enable content encryption for the broadcast.
     *
     * @return $this
     */
    public function setEnableContentEncryption($enable_content_encryption)
    {
        $this->container['enable_content_encryption'] = $enable_content_encryption;

        return $this;
    }

    /**
     * Gets enable_dvr
     *
     * @return bool
     */
    public function getEnableDvr()
    {
        return $this->container['enable_dvr'];
    }

    /**
     * Sets enable_dvr
     *
     * @param bool $enable_dvr This setting determines whether viewers can access DVR controls while watching the video. DVR controls enable the viewer to control the video playback experience by pausing, rewinding, or fast forwarding content. The default value for this property is true.    Important: You must set the value to true and also set the enableArchive property's value to true if you want to make playback available immediately after the broadcast ends.
     *
     * @return $this
     */
    public function setEnableDvr($enable_dvr)
    {
        $this->container['enable_dvr'] = $enable_dvr;

        return $this;
    }

    /**
     * Gets enable_embed
     *
     * @return bool
     */
    public function getEnableEmbed()
    {
        return $this->container['enable_embed'];
    }

    /**
     * Sets enable_embed
     *
     * @param bool $enable_embed This setting indicates whether the broadcast video can be played in an embedded player. If you choose to archive the video (using the enableArchive property), this setting will also apply to the archived video.
     *
     * @return $this
     */
    public function setEnableEmbed($enable_embed)
    {
        $this->container['enable_embed'] = $enable_embed;

        return $this;
    }

    /**
     * Gets enable_low_latency
     *
     * @return bool
     */
    public function getEnableLowLatency()
    {
        return $this->container['enable_low_latency'];
    }

    /**
     * Sets enable_low_latency
     *
     * @param bool $enable_low_latency Indicates whether this broadcast has low latency enabled.
     *
     * @return $this
     */
    public function setEnableLowLatency($enable_low_latency)
    {
        $this->container['enable_low_latency'] = $enable_low_latency;

        return $this;
    }

    /**
     * Gets latency_preference
     *
     * @return string
     */
    public function getLatencyPreference()
    {
        return $this->container['latency_preference'];
    }

    /**
     * Sets latency_preference
     *
     * @param string $latency_preference If both this and enable_low_latency are set, they must match. LATENCY_NORMAL should match enable_low_latency=false LATENCY_LOW should match enable_low_latency=true LATENCY_ULTRA_LOW should have enable_low_latency omitted.
     *
     * @return $this
     */
    public function setLatencyPreference($latency_preference)
    {
        $allowedValues = $this->getLatencyPreferenceAllowableValues();
        if (!is_null($latency_preference) && !in_array($latency_preference, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'latency_preference', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['latency_preference'] = $latency_preference;

        return $this;
    }

    /**
     * Gets mesh
     *
     * @return string
     */
    public function getMesh()
    {
        return $this->container['mesh'];
    }

    /**
     * Sets mesh
     *
     * @param string $mesh mesh
     *
     * @return $this
     */
    public function setMesh($mesh)
    {

        if (!is_null($mesh) && (!preg_match("/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/", $mesh))) {
            throw new \InvalidArgumentException("invalid value for $mesh when calling LiveBroadcastContentDetails., must conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.");
        }

        $this->container['mesh'] = $mesh;

        return $this;
    }

    /**
     * Gets monitor_stream
     *
     * @return \Swagger\Client\Model\MonitorStreamInfo
     */
    public function getMonitorStream()
    {
        return $this->container['monitor_stream'];
    }

    /**
     * Sets monitor_stream
     *
     * @param \Swagger\Client\Model\MonitorStreamInfo $monitor_stream The monitorStream object contains information about the monitor stream, which the broadcaster can use to review the event content before the broadcast stream is shown publicly.
     *
     * @return $this
     */
    public function setMonitorStream($monitor_stream)
    {
        $this->container['monitor_stream'] = $monitor_stream;

        return $this;
    }

    /**
     * Gets projection
     *
     * @return string
     */
    public function getProjection()
    {
        return $this->container['projection'];
    }

    /**
     * Sets projection
     *
     * @param string $projection The projection format of this broadcast. This defaults to rectangular.
     *
     * @return $this
     */
    public function setProjection($projection)
    {
        $allowedValues = $this->getProjectionAllowableValues();
        if (!is_null($projection) && !in_array($projection, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'projection', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['projection'] = $projection;

        return $this;
    }

    /**
     * Gets record_from_start
     *
     * @return bool
     */
    public function getRecordFromStart()
    {
        return $this->container['record_from_start'];
    }

    /**
     * Sets record_from_start
     *
     * @param bool $record_from_start Automatically start recording after the event goes live. The default value for this property is true.    Important: You must also set the enableDvr property's value to true if you want the playback to be available immediately after the broadcast ends. If you set this property's value to true but do not also set the enableDvr property to true, there may be a delay of around one day before the archived video will be available for playback.
     *
     * @return $this
     */
    public function setRecordFromStart($record_from_start)
    {
        $this->container['record_from_start'] = $record_from_start;

        return $this;
    }

    /**
     * Gets start_with_slate
     *
     * @return bool
     */
    public function getStartWithSlate()
    {
        return $this->container['start_with_slate'];
    }

    /**
     * Sets start_with_slate
     *
     * @param bool $start_with_slate This setting indicates whether the broadcast should automatically begin with an in-stream slate when you update the broadcast's status to live. After updating the status, you then need to send a liveCuepoints.insert request that sets the cuepoint's eventState to end to remove the in-stream slate and make your broadcast stream visible to viewers.
     *
     * @return $this
     */
    public function setStartWithSlate($start_with_slate)
    {
        $this->container['start_with_slate'] = $start_with_slate;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


